#!/usr/bin/env python
#
# setup.py
#
from setuptools import setup, find_packages
import os
import io
import sys
import subprocess


### Locations ################################################################
# The directory in which this setup.py lives
here = os.path.abspath(os.path.dirname(__file__))
# Directory scripts for abstracted vcs interactions
vcs_tools = os.path.join(here, 'vcs')
# Location of cached version file. This is a module inside the main package so
# code has access to the version string at runtime, and is set here in
# setup.py. It's also used to cache the version string from the vcs tag name
# so the package installation doesn't have to take place in the presence of the
# vcs (like installing from an sdist).
__version_py = os.path.join(*[
    here, 'package', '__version', '__version.py'
])


### Use the contents of the README as the long description ###################
with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f:
    long_description = f.read()


#### Get the version from source control #####################################
# Helper for getting the package version from version control tags, etc.
def get_version_from_vcs():
    FAILED_TO_GET_VERSION = '__failed__'

    script = os.path.join(vcs_tools, "get_version.sh")
    try:
        vcs_version = subprocess.check_output([script]).rstrip()
    except:
        vcs_version = FAILED_TO_GET_VERSION

    # Can't get any sort of a version
    if vcs_version == '' or vcs_version == FAILED_TO_GET_VERSION:
        vcs_version = None

    return vcs_version

# Helper for getting a cached version string from a file
def get_version_from_file():
    if os.path.isfile(__version_py):
        sys.path.append(os.path.dirname(__version_py))
        import __version
        cached_version = __version.VERSION
    else:
        cached_version = None

    return cached_version

# Helper for writing the cached version file
def write_version_file(version):
    with io.open(__version_py, 'w', encoding='utf-8') as f:
        comment_line = "# Do not edit this file, version set by setup.py"
        version_line = "VERSION = '{v}'".format(v=version)
        f.write(unicode(comment_line + os.linesep + version_line))

# Check vcs first. If it succeeds, then update the version file. If not, then
# fallback to an existing version file.
version = get_version_from_vcs()
if version is not None:
    # Got good version from vcs, cache it
    write_version_file(version)
else:
    # Version from vcs failed, so try the file
    version = get_version_from_file()
if version is None:
    # Couldn't get a version, so default to something
    version = 'PRE-TAG-SNAPSHOT'
    # Or bail out
    # raise Exception(
    #     "Couldn't determine version. "
    #     "Neither vcs nor version file are available. :("
    # )


### Do The Thing #############################################################
# FIXME Fill in the blanks, here.
setup(
    # PyPI Metadata ###
    name='boilerplate_package',
    version=version,
    description='__SHORT_DESC_HERE__',
    long_description=long_description,
    url='__URL_HERE__',
    author='__AUTHOR_HERE__',
    author_email='__AUTHOR_EMAIL_HERE__',
    license='BSD',
    classifiers=[
        # How mature is this project? Common values are
        #   3 - Alpha
        #   4 - Beta
        #   5 - Production/Stable
        'Development Status :: 3 - Alpha',

        # Pick your license as you wish (should match "license" above)
        'License :: OSI Approved :: BSD License',

        # Specify the Python versions you support here. In particular, ensure
        # that you indicate whether you support Python 2, Python 3 or both.
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 2.7',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.4',
        'Programming Language :: Python :: 3.5',
    ],
    keywords='KEYWORDS, HERE',

    # The Business ###
    packages=find_packages(),

    # Dependencies ###
    install_requires=[
    ],

    # Included Data ###
    package_data={
    },
    data_files=[
        # Include README for documentation, but also because it's used as the
        # long_description. So an install from an sdist would fail without it.
        ('README.md', ['README.md']),
        # Include license file
        # ('LICENSE.txt', ['LICENSE.txt']),
    ],

    # CLI Scripts ###
    entry_points={
        'console_scripts': [
            'boilerplate=package.boilerplate:main'
        ],
    },
)
